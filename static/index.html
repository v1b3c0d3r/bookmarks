<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bookmark Manager</title>
    <link rel="icon" href="static/favicon.svg">
    <link rel="manifest" href="static/manifest.json" crossorigin="use-credentials"/>
    <script src="static/tailwind_css.js"></script>
    <link rel="stylesheet" href="static/all.min.css">
    <style>
        /* Custom scrollbar for a cleaner look */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        /* Custom styles for drag-over effect */
        .drag-over { background-color: #e0f2fe !important; border: 1px dashed #0ea5e9 !important; }
        /* Hide default arrow for summary/details */
        summary::-webkit-details-marker { display: none; }
        .folder-tree-root-drag-over { background-color: #f0f9ff; }
    </style>
</head>
<body class="bg-slate-100 font-sans text-slate-800">

    <div id="app" class="flex h-screen">
        <!-- Sidebar for Folders -->
        <aside class="w-1/3 max-w-xs h-screen bg-white border-r border-slate-200 flex flex-col">
            <div class="p-4 border-b border-slate-200 flex justify-between items-center">
                <h1 class="text-lg font-bold">Folders</h1>
                <button id="add-folder-root-btn" class="text-slate-500 hover:text-sky-500 transition-colors">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            <div id="folder-tree" class="flex-grow overflow-y-auto p-2 transition-colors">
                <!-- Folder structure will be rendered here -->
            </div>
        </aside>

        <!-- Main Content for Bookmarks -->
        <main class="flex-grow h-screen flex flex-col">
            <header class="p-4 border-b border-slate-200 bg-white flex justify-between items-center">
                <h2 id="current-folder-name" class="text-lg font-bold">All Bookmarks</h2>
                <button id="add-bookmark-btn" class="bg-sky-500 text-white px-4 py-2 rounded-lg hover:bg-sky-600 transition-colors font-semibold shadow-sm">
                    <i class="fas fa-plus mr-2"></i>Add Bookmark
                </button>
            </header>
            <div id="bookmark-list" class="flex-grow overflow-y-auto p-4 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 content-start">
                <!-- Bookmarks will be rendered here -->
            </div>
            <div id="empty-state" class="hidden flex-col items-center justify-center h-full text-slate-500">
                 <i class="fas fa-folder-open fa-4x mb-4"></i>
                 <p class="text-xl">This folder is empty.</p>
                 <p>Add a bookmark to get started.</p>
            </div>
        </main>
    </div>

    <!-- Modal for Add/Edit Bookmark/Folder -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h3 id="modal-title" class="text-xl font-bold mb-4">Modal Title</h3>
            <form id="modal-form">
                <input type="hidden" id="edit-id">
                <input type="hidden" id="edit-type">
                <input type="hidden" id="item-parent-id">
                
                <div class="mb-4">
                    <label for="item-name" class="block text-sm font-medium text-slate-700 mb-1">Name</label>
                    <input type="text" id="item-name" class="w-full border border-slate-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-500" required>
                </div>
                
                <div id="url-field" class="mb-4">
                    <label for="item-url" class="block text-sm font-medium text-slate-700 mb-1">URL</label>
                    <input type="url" id="item-url" class="w-full border border-slate-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-500" placeholder="https://example.com">
                </div>

                <div class="flex justify-end space-x-3">
                    <button type="button" id="modal-cancel-btn" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg hover:bg-slate-300 transition-colors font-semibold">Cancel</button>
                    <button type="submit" class="bg-sky-500 text-white px-4 py-2 rounded-lg hover:bg-sky-600 transition-colors font-semibold">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Custom Context Menu -->
    <div id="context-menu" class="hidden absolute bg-white border border-slate-200 rounded-md shadow-lg py-1 w-40 z-50">
        <button data-action="edit" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-sky-500"><i class="fas fa-pencil-alt w-6"></i>Edit</button>
        <button data-action="delete" class="w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50"><i class="fas fa-trash-alt w-6"></i>Delete</button>
        <button data-action="add-subfolder" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-sky-500"><i class="fas fa-folder-plus w-6"></i>New Subfolder</button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS ---
        const folderTreeEl = document.getElementById('folder-tree');
        const bookmarkListEl = document.getElementById('bookmark-list');
        const currentFolderNameEl = document.getElementById('current-folder-name');
        const modalEl = document.getElementById('modal');
        const modalForm = document.getElementById('modal-form');
        const modalTitleEl = document.getElementById('modal-title');
        const urlField = document.getElementById('url-field');
        const editIdInput = document.getElementById('edit-id');
        const editTypeInput = document.getElementById('edit-type');
        const itemParentIdInput = document.getElementById('item-parent-id');
        const itemNameInput = document.getElementById('item-name');
        const itemUrlInput = document.getElementById('item-url');
        const contextMenuEl = document.getElementById('context-menu');
        const emptyStateEl = document.getElementById('empty-state');

        // --- GLOBAL STATE (UI-related) ---
        let allBookmarks = [];
        let allFolders = [];
        let currentFolderId = null;
        let contextTarget = null;

        // --- API HELPERS ---
        const api = {
            async request(endpoint, options = {}) {
                options.headers = { 'Content-Type': 'application/json', ...options.headers };
                const response = await fetch(`api${endpoint}`, options);
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'API request failed');
                }
                if (response.status === 204) return; // No Content
                return response.json();
            },
            getData: () => api.request('/data'),
            createBookmark: (data) => api.request('/bookmarks', { method: 'POST', body: JSON.stringify(data) }),
            createFolder: (data) => api.request('/folders', { method: 'POST', body: JSON.stringify(data) }),
            updateItem: (type, id, data) => api.request(`/items/${type}/${id}`, { method: 'PUT', body: JSON.stringify(data) }),
            deleteItem: (type, id) => api.request(`/items/${type}/${id}`, { method: 'DELETE' }),
        };

        // --- DATA HELPERS ---
        const findItem = (id, type) => (type === 'folder' ? allFolders : allBookmarks).find(item => item.id === id);
        const getSubFolders = (parentId) => allFolders.filter(f => f.parentId === parentId);
        const getBookmarksInFolder = (folderId) => allBookmarks.filter(b => b.folderId === folderId);

        // --- RENDER FUNCTIONS ---
        const render = () => {
            renderFolderTree();
            renderBookmarks();
        };

        const renderFolderTree = () => {
            folderTreeEl.innerHTML = '';
            getSubFolders(null).forEach(folder => folderTreeEl.appendChild(createFolderElement(folder, 0)));
        };

        const createFolderElement = (folder, level) => {
            const details = document.createElement('details');
            details.open = folder.isOpen;
            details.dataset.id = folder.id;
            details.dataset.type = 'folder';
            details.style.marginLeft = `${20}px`;
            details.classList.add('rounded-md');

            const summary = document.createElement('summary');
            summary.classList.add('p-2', 'rounded-md', 'cursor-pointer', 'hover:bg-slate-100', 'flex', 'items-center', 'justify-between', 'list-none');
            if (folder.id === currentFolderId) {
                summary.classList.add('bg-sky-100', 'text-sky-700', 'font-semibold');
                currentFolderNameEl.textContent = folder.name;
            }

            const folderIcon = folder.isOpen ? 'fa-folder-open' : 'fa-folder';
            const chevronIcon = getSubFolders(folder.id).length > 0 ? `<i class="chevron-icon fas fa-chevron-down transition-transform ${folder.isOpen ? 'rotate-0' : '-rotate-90'}"></i>` : '<div class="w-4"></div>';
            
            summary.innerHTML = `<div class="flex items-center overflow-hidden"><i class="fas ${folderIcon} w-6 text-sky-500"></i><span class="ml-2 truncate">${folder.name}</span></div>${chevronIcon}`;
            details.appendChild(summary);

            getSubFolders(folder.id).forEach(subFolder => details.appendChild(createFolderElement(subFolder, level + 1)));

            // Select folder when clicking anywhere except chevron
            summary.addEventListener('click', async (e) => {
                if (e.button !== 0) return; // left-click only
                // If click was on chevron, skip selection (chevron handler will run)
                if (e.target.closest('.chevron-icon')) return;

                e.preventDefault();
                currentFolderId = folder.id;
                currentFolderNameEl.textContent = folder.name;
                await loadData(); // no toggle, just selection
            });

            // Toggle open/close when clicking chevron
            const chevronEl = summary.querySelector('.chevron-icon');
            if (chevronEl) {
                chevronEl.addEventListener('click', async (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation(); // prevent summary click from firing
                    e.preventDefault();
                    const newIsOpenState = !folder.isOpen;
                    await api.updateItem('folders', folder.id, { isOpen: newIsOpenState });
                    await loadData();
                });
            }

            makeDraggable(summary);
            makeDroppable(summary);

            summary.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                contextTarget = { id: folder.id, type: 'folder' };
                showContextMenu(e.pageX, e.pageY, true);
            });

            return details;
        };

        const renderBookmarks = () => {
            bookmarkListEl.innerHTML = '';
            const bookmarksToRender = getBookmarksInFolder(currentFolderId);

            emptyStateEl.classList.toggle('hidden', bookmarksToRender.length > 0 || currentFolderId === null);
            emptyStateEl.classList.toggle('flex', bookmarksToRender.length === 0 && currentFolderId !== null);
            bookmarkListEl.classList.toggle('hidden', bookmarksToRender.length === 0 && currentFolderId !== null);
            
            if(currentFolderId === null) currentFolderNameEl.textContent = "All Bookmarks";

            bookmarksToRender.forEach(bookmark => {
                const bookmarkEl = document.createElement('div');
                bookmarkEl.dataset.id = bookmark.id;
                bookmarkEl.dataset.type = 'bookmark';
                bookmarkEl.className = 'bg-white p-4 rounded-lg shadow-sm border border-slate-200 hover:shadow-md hover:border-sky-300 transition-all cursor-pointer h-28';
                const faviconUrl = new URL('favicon.ico', bookmark.url).href;
                bookmarkEl.innerHTML = `
                    <div class="flex items-center mb-2">
                        <img 
                        src="api/favicon/${bookmark.id}" 
                        onerror="this.onerror=null; this.src='static/weblink.png';" 
                        class="w-5 h-5 mr-3 flex-shrink-0" 
                        alt="favicon"
                        >
                        <h4 class="font-bold truncate">${bookmark.name}</h4>
                    </div>
                    <p class="text-xs text-slate-500 break-all">${bookmark.url}</p>
                `;
                bookmarkListEl.appendChild(bookmarkEl);
                
                bookmarkEl.addEventListener('click', () => window.open(bookmark.url, '_blank'));
                bookmarkEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    contextTarget = { id: bookmark.id, type: 'bookmark' };
                    showContextMenu(e.pageX, e.pageY, false);
                });
                makeDraggable(bookmarkEl);
            });
        };

        // --- MODAL LOGIC ---
        const openModal = (type, mode, item = null, parentId = null) => {
            modalForm.reset();
            editTypeInput.value = type;
            editIdInput.value = item ? item.id : '';
            itemParentIdInput.value = parentId || '';
            
            urlField.style.display = (type === 'bookmark') ? 'block' : 'none';
            itemUrlInput.required = (type === 'bookmark');

            if (mode === 'add') {
                modalTitleEl.textContent = type === 'bookmark' ? 'Add New Bookmark' : 'Add New Folder';
            } else { // edit
                modalTitleEl.textContent = type === 'bookmark' ? 'Edit Bookmark' : 'Edit Folder';
                itemNameInput.value = item.name;
                if (type === 'bookmark') itemUrlInput.value = item.url;
            }
            modalEl.classList.remove('hidden');
            itemNameInput.focus();
        };

        const closeModal = () => modalEl.classList.add('hidden');

        modalForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const id = editIdInput.value ? parseInt(editIdInput.value) : null;
            const type = editTypeInput.value;
            const name = itemNameInput.value.trim();

            try {
                if (id) { // Edit existing item
                    const payload = { name };
                    if (type === 'bookmark') payload.url = itemUrlInput.value.trim();
                    await api.updateItem(type + 's', id, payload);
                } else { // Create new item
                    if (type === 'bookmark') {
                        await api.createBookmark({ name, url: itemUrlInput.value.trim(), folderId: currentFolderId });
                    } else { // folder
                        const parentId = itemParentIdInput.value ? parseInt(itemParentIdInput.value) : null;
                        await api.createFolder({ name, parentId });
                        await api.updateItem('folders', parentId, { isOpen: true }).catch(() => {});
                    }
                }
                closeModal();
                await loadData();
            } catch (err) {
                console.error('Failed to save item:', err);
                alert('Error: ' + err.message);
            }
        });

        // --- CONTEXT MENU LOGIC (FIXED) ---
        const showContextMenu = (x, y, isFolder) => {
            hideContextMenu();
            contextMenuEl.style.left = `${x}px`;
            contextMenuEl.style.top = `${y}px`;
            contextMenuEl.classList.remove('hidden');
            contextMenuEl.querySelector('[data-action="add-subfolder"]').style.display = isFolder ? 'block' : 'none';
        };

        const hideContextMenu = () => {
            contextMenuEl.classList.add('hidden');
        };

        contextMenuEl.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent the global document click from firing
            e.preventDefault();

            const targetButton = e.target.closest('button');
            if (!targetButton) return;

            const action = targetButton.dataset.action;
            const localContext = contextTarget; // Copy so it survives after menu close
            if (!localContext) return;

            const { id, type } = localContext;
            const item = findItem(id, type);

            if (!item) {
                console.error("Context item not found:", localContext);
                return;
            }

            // Perform the action before hiding the menu
            if (action === 'edit') {
                openModal(type, 'edit', item);
            } else if (action === 'delete') {
                if (confirm(`Are you sure you want to delete "${item.name}"? This cannot be undone.`)) {
                    if (type === 'folder') {
                        // Save parent ID before deletion
                        parentId = item.parentId ?? null;
                    }
                    await api.deleteItem(type + 's', id);
                    // Auto-select parent folder if we deleted a folder
                    if (type === 'folder') {
                        currentFolderId = parentId;
                    }
                    await loadData();
                }
            } else if (action === 'add-subfolder') {
                openModal('folder', 'add', null, id);
            }

            // Now hide the menu
            hideContextMenu();
            contextTarget = null;
        });

        // --- DRAG AND DROP LOGIC ---
        let draggedElement = null;

        function makeDraggable(el) {
            el.setAttribute('draggable', 'true');
            el.addEventListener('dragstart', (e) => {
                e.stopPropagation();
                const target = e.target.closest('[data-id]');
                draggedElement = { id: parseInt(target.dataset.id), type: target.dataset.type };
                e.dataTransfer.setData('text/plain', '');
                setTimeout(() => target.classList.add('opacity-50'), 0);
            });
            el.addEventListener('dragend', (e) => {
                draggedElement = null;
                document.querySelectorAll('.opacity-50, .drag-over').forEach(d => d.classList.remove('opacity-50', 'drag-over'));
            });
        }

        function makeDroppable(el) {
            el.addEventListener('dragover', (e) => {
                e.preventDefault(); e.stopPropagation();
                const targetFolderEl = e.target.closest('[data-type="folder"]');
                if (targetFolderEl) {
                    const targetId = parseInt(targetFolderEl.dataset.id);
                    if (draggedElement && (draggedElement.id !== targetId || draggedElement.type !== 'folder')) {
                       targetFolderEl.querySelector('summary').classList.add('drag-over');
                    }
                }
            });
            el.addEventListener('dragleave', (e) => {
                e.stopPropagation();
                e.target.closest('summary')?.classList.remove('drag-over');
            });
            el.addEventListener('drop', async (e) => {
                e.preventDefault(); e.stopPropagation();
                const targetFolderEl = e.target.closest('[data-type="folder"]');
                targetFolderEl.querySelector('summary').classList.remove('drag-over');
                if (!draggedElement) return;
                const targetFolderId = parseInt(targetFolderEl.dataset.id);
                let payload = {};
                if (draggedElement.type === 'bookmark') {
                    payload.folderId = targetFolderId;
                } else if (draggedElement.type === 'folder') {
                    if (draggedElement.id == targetFolderId) return;
                    payload.parentId = targetFolderId;
                }
                await api.updateItem(draggedElement.type + 's', draggedElement.id, payload);
                await loadData();
            });
        }
        
        folderTreeEl.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (draggedElement?.type === 'folder') folderTreeEl.classList.add('folder-tree-root-drag-over');
        });
        folderTreeEl.addEventListener('dragleave', () => folderTreeEl.classList.remove('folder-tree-root-drag-over'));
        folderTreeEl.addEventListener('drop', async (e) => {
            folderTreeEl.classList.remove('folder-tree-root-drag-over');
            if (e.target === folderTreeEl && draggedElement?.type === 'folder') {
                await api.updateItem('folders', draggedElement.id, { parentId: 0 }); // Use 0 for root
                await loadData();
            }
        });

        // --- INITIALIZATION ---
        const loadData = async () => {
            try {
                const data = await api.getData();
                allFolders = data.folders;
                allBookmarks = data.bookmarks;

                // Auto-close leaf folders (no subfolders)
                allFolders.forEach(folder => {
                    const hasChildren = allFolders.some(f => f.parentId === folder.id);
                    if (!hasChildren && folder.isOpen) {
                        folder.isOpen = false;
                        // Optionally update backend so it stays closed in DB
                        api.updateItem('folders', folder.id, { isOpen: false }).catch(() => {});
                    }
                });

                render();
            } catch (err) {
                console.error('Failed to load data:', err);
                document.body.innerHTML = `<div class="text-center p-8 text-red-600"><h2>Connection Error</h2><p>Could not connect to the backend server. Is it running?</p><p>${err.message}</p></div>`;
            }
        };

        // --- GLOBAL EVENT LISTENERS ---
        document.getElementById('add-bookmark-btn').addEventListener('click', () => {
            if (currentFolderId !== null) openModal('bookmark', 'add');
            else alert("Please select a folder first to add a bookmark.");
        });
        document.getElementById('add-folder-root-btn').addEventListener('click', () => openModal('folder', 'add', null, null));
        document.getElementById('modal-cancel-btn').addEventListener('click', closeModal);
        modalEl.addEventListener('click', (e) => { if (e.target === modalEl) closeModal(); });
        document.addEventListener('click', (e) => { if (!contextMenuEl.contains(e.target)) hideContextMenu(); });

        loadData();
    });

    if ('serviceWorker' in navigator) {
        navigator.serviceWorker
            .register('sw.js', {updateViaCache: 'none', scope: window.location.pathname})
            .then((reg) => {
                if (reg.active) 
                    reg.active.postMessage('fetched latest service worker script');
                else 
                    console.info('Service worker registered');
            });
    }
    </script>
</body>
</html>
