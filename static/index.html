<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bookmark Manager</title>
    <link rel="icon" href="static/favicon.svg">
    <link rel="manifest" href="static/manifest.json" crossorigin="use-credentials"/>
    <script src="static/tailwind_css.js"></script>
    <link rel="stylesheet" href="static/all.min.css">
    <style>
        /* Custom scrollbar for a cleaner look */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        /* Custom styles for drag-over effect */
        .drag-over { background-color: #e0f2fe !important; border: 1px dashed #0ea5e9 !important; }
        /* Hide default arrow for summary/details */
        summary::-webkit-details-marker { display: none; }
        .folder-tree-root-drag-over { background-color: #f0f9ff; }
        .drag-placeholder {
            background-color: #e0f2fe;
            border: 2px dashed #93c5fd;
        }
    </style>
    <style>
        .dark {
            --slate-100: #1e293b;
            --slate-800: #f1f5f9;
            --white: #0f172a;
            --slate-200: #334155;
            --slate-500: #94a3b8;
            --sky-500: #0ea5e9;
            --sky-600: #0284c7;
            --sky-100: #0c4a6e;
            --sky-700: #e0f2fe;
            --slate-700: #f1f5f9;
            --slate-300: #475569;
            --red-600: #f87171;
            --red-50: #450a0a;
        }
        .dark body { background-color: var(--slate-100); color: var(--slate-800); }
        .dark aside { background-color: var(--white); border-color: var(--slate-200); }
        .dark header { background-color: var(--white); border-color: var(--slate-200); }
        .dark #folder-tree { background-color: var(--white); }
        .dark .hover\:bg-slate-100:hover { background-color: var(--slate-100); }
        .dark summary.bg-sky-100 { background-color: var(--sky-100); color: var(--sky-700); }
        .dark #bookmark-list > div { background-color: var(--white); border-color: var(--slate-200); }
        .dark #bookmark-list > div:hover { border-color: var(--sky-500); }
        .dark #empty-state { color: var(--slate-500); }
        .dark #modal div { background-color: var(--white); color: var(--slate-800); }
        .dark #modal input { background-color: var(--slate-100); border-color: var(--slate-300); color: var(--slate-800); }
        .dark #modal label { color: var(--slate-700); }
        .dark #context-menu { background-color: var(--white); border-color: var(--slate-200); }
        .dark #context-menu button:hover { background-color: var(--slate-100); }
        .dark #context-menu button[data-action="delete"]:hover { background-color: var(--red-50); color: var(--red-600); }
        .dark ::-webkit-scrollbar-track { background: var(--slate-100); }
        .dark ::-webkit-scrollbar-thumb { background: var(--slate-200); }
        .dark ::-webkit-scrollbar-thumb:hover { background: var(--slate-500); }
        .dark #theme-toggle-btn { color: var(--slate-500); }
        .dark #theme-toggle-btn:hover { color: var(--sky-500); }
        .dark .text-slate-500 { color: var(--slate-500); }
    </style>
</head>
<body class="bg-slate-100 font-sans text-slate-800">

    <div id="drag-separator" class="hidden absolute bg-slate-700 z-50"></div>

    <div id="app" class="flex h-screen">
        <!-- Sidebar for Folders -->
        <aside class="w-1/3 max-w-xs h-screen bg-white border-r border-slate-200 flex flex-col">
            <div class="p-4 border-b border-slate-200 flex justify-between items-center">
                <h1 class="text-lg font-bold">Folders</h1>
                <button id="add-folder-root-btn" class="text-slate-500 hover:text-sky-500 transition-colors">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            <div id="folder-tree" class="flex-grow overflow-y-auto p-2 transition-colors">
                <!-- Folder structure will be rendered here -->
            </div>
        </aside>

        <!-- Main Content for Bookmarks -->
        <main class="flex-grow h-screen flex flex-col">
            <header class="p-4 border-b border-slate-200 bg-white flex justify-between items-center">
                <h2 id="current-folder-name" class="text-lg font-bold">All Bookmarks</h2>
                <div class="flex items-center">
                    <button id="theme-toggle-btn" class="text-slate-500 hover:text-sky-500 transition-colors mr-4">
                        <i class="fas fa-sun"></i>
                        <i class="fas fa-moon hidden"></i>
                    </button>
                    <button id="add-bookmark-btn" class="bg-sky-500 text-white px-4 py-2 rounded-lg hover:bg-sky-600 transition-colors font-semibold shadow-sm">
                        <i class="fas fa-plus mr-2"></i>Add Bookmark
                    </button>
                </div>
            </header>
            <div id="bookmark-list" class="flex-grow overflow-y-auto p-4 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 content-start">
                <!-- Bookmarks will be rendered here -->
            </div>
            <div id="empty-state" class="hidden flex-col items-center justify-center h-full text-slate-500">
                 <i class="fas fa-folder-open fa-4x mb-4"></i>
                 <p class="text-xl">This folder is empty.</p>
                 <p>Add a bookmark to get started.</p>
            </div>
        </main>
    </div>

    <!-- Modal for Add/Edit Bookmark/Folder -->
    <div id="modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h3 id="modal-title" class="text-xl font-bold mb-4">Modal Title</h3>
            <form id="modal-form">
                <input type="hidden" id="edit-id">
                <input type="hidden" id="edit-type">
                <input type="hidden" id="item-parent-id">
                
                <div class="mb-4">
                    <label for="item-name" class="block text-sm font-medium text-slate-700 mb-1">Name</label>
                    <input type="text" id="item-name" class="w-full border border-slate-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-500" required>
                </div>
                
                <div id="url-field" class="mb-4">
                    <label for="item-url" class="block text-sm font-medium text-slate-700 mb-1">URL</label>
                    <input type="url" id="item-url" class="w-full border border-slate-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-500" placeholder="https://example.com">
                </div>

                <div class="flex justify-end space-x-3">
                    <button type="button" id="modal-cancel-btn" class="bg-slate-200 text-slate-800 px-4 py-2 rounded-lg hover:bg-slate-300 transition-colors font-semibold">Cancel</button>
                    <button type="submit" class="bg-sky-500 text-white px-4 py-2 rounded-lg hover:bg-sky-600 transition-colors font-semibold">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Custom Context Menu -->
    <div id="context-menu" class="hidden absolute bg-white border border-slate-200 rounded-md shadow-lg py-1 w-40 z-50">
        <button data-action="edit" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-sky-500"><i class="fas fa-pencil-alt w-6"></i>Edit</button>
        <button data-action="delete" class="w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50"><i class="fas fa-trash-alt w-6"></i>Delete</button>
        <button data-action="add-subfolder" class="w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-sky-500"><i class="fas fa-folder-plus w-6"></i>New Subfolder</button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS ---
        const folderTreeEl = document.getElementById('folder-tree');
        const bookmarkListEl = document.getElementById('bookmark-list');
        const currentFolderNameEl = document.getElementById('current-folder-name');
        const modalEl = document.getElementById('modal');
        const modalForm = document.getElementById('modal-form');
        const modalTitleEl = document.getElementById('modal-title');
        const urlField = document.getElementById('url-field');
        const editIdInput = document.getElementById('edit-id');
        const editTypeInput = document.getElementById('edit-type');
        const itemParentIdInput = document.getElementById('item-parent-id');
        const itemNameInput = document.getElementById('item-name');
        const itemUrlInput = document.getElementById('item-url');
        const contextMenuEl = document.getElementById('context-menu');
        const emptyStateEl = document.getElementById('empty-state');

        // --- GLOBAL STATE (UI-related) ---
        let allBookmarks = [];
        let allFolders = [];
        let currentFolderId = null;
        let contextTarget = null;
        let dragAction = null;
        let dragOverContainer = null;
        let dragTimeout = null;

        // --- API HELPERS ---
        const api = {
            async request(endpoint, options = {}) {
                options.headers = { 'Content-Type': 'application/json', ...options.headers };
                const response = await fetch(`api${endpoint}`, options);
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'API request failed');
                }
                if (response.status === 204) return; // No Content
                return response.json();
            },
            getData: () => api.request('/data'),
            createBookmark: (data) => api.request('/bookmarks', { method: 'POST', body: JSON.stringify(data) }),
            createFolder: (data) => api.request('/folders', { method: 'POST', body: JSON.stringify(data) }),
            updateItem: (type, id, data) => api.request(`/items/${type}/${id}`, { method: 'PUT', body: JSON.stringify(data) }),
            deleteItem: (type, id) => api.request(`/items/${type}/${id}`, { method: 'DELETE' }),
            reorderItems: (type, ids) => api.request(`/items/${type}/reorder`, { method: 'POST', body: JSON.stringify({ ids }) }),
        };

        // --- DATA HELPERS ---
        const findItem = (id, type) => (type === 'folder' ? allFolders : allBookmarks).find(item => item.id === id);
        const getSubFolders = (parentId) => allFolders.filter(f => f.parentId === parentId).sort((a,b) => a.position - b.position);
        const getBookmarksInFolder = (folderId) => allBookmarks.filter(b => b.folderId === folderId).sort((a,b) => a.position - b.position);

        // --- RENDER FUNCTIONS ---
        const render = () => {
            renderFolderTree();
            renderBookmarks();
        };

        const renderFolderTree = () => {
            folderTreeEl.innerHTML = '';
            getSubFolders(null).forEach(folder => folderTreeEl.appendChild(createFolderElement(folder, 0)));
        };

        const createFolderElement = (folder, level) => {
            const details = document.createElement('details');
            details.open = folder.isOpen;
            details.dataset.id = folder.id;
            details.dataset.type = 'folder';
            details.style.marginLeft = `${20}px`;
            details.classList.add('rounded-md');

            details.setAttribute('draggable', 'true');
            details.addEventListener('dragstart', e => onDragStart(e, folder, 'folder'));
            details.addEventListener('dragover', e => onFolderDragOver(e, folder));
            details.addEventListener('dragleave', e => onFolderDragLeave(e));
            details.addEventListener('drop', e => onFolderDrop(e, folder));

            const summary = document.createElement('summary');
            summary.classList.add('p-2', 'rounded-md', 'cursor-pointer', 'hover:bg-slate-100', 'flex', 'items-center', 'justify-between', 'list-none');
            if (folder.id === currentFolderId) {
                summary.classList.add('bg-sky-100', 'text-sky-700', 'font-semibold');
                currentFolderNameEl.textContent = folder.name;
            }

            const folderIcon = folder.isOpen ? 'fa-folder-open' : 'fa-folder';
            const chevronIcon = getSubFolders(folder.id).length > 0 ? `<i class="chevron-icon fas fa-chevron-down transition-transform ${folder.isOpen ? 'rotate-0' : '-rotate-90'}"></i>` : '<div class="w-4"></div>';
            
            summary.innerHTML = `<div class="flex items-center overflow-hidden"><i class="fas ${folderIcon} w-6 text-sky-500"></i><span class="ml-2 truncate">${folder.name}</span></div>${chevronIcon}`;
            details.appendChild(summary);

            getSubFolders(folder.id).forEach(subFolder => details.appendChild(createFolderElement(subFolder, level + 1)));

            // Select folder when clicking anywhere except chevron
            summary.addEventListener('click', async (e) => {
                if (e.button !== 0) return; // left-click only
                // If click was on chevron, skip selection (chevron handler will run)
                if (e.target.closest('.chevron-icon')) return;

                e.preventDefault();
                currentFolderId = folder.id;
                currentFolderNameEl.textContent = folder.name;
                await loadData(); // no toggle, just selection
            });

            // Toggle open/close when clicking chevron
            const chevronEl = summary.querySelector('.chevron-icon');
            if (chevronEl) {
                chevronEl.addEventListener('click', async (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation(); // prevent summary click from firing
                    e.preventDefault();
                    const newIsOpenState = !folder.isOpen;
                    await api.updateItem('folders', folder.id, { isOpen: newIsOpenState });
                    await loadData();
                });
            }

            summary.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                contextTarget = { id: folder.id, type: 'folder' };
                showContextMenu(e.pageX, e.pageY, true);
            });

            return details;
        };

        const renderBookmarks = () => {
            bookmarkListEl.innerHTML = '';
            const bookmarksToRender = getBookmarksInFolder(currentFolderId);

            emptyStateEl.classList.toggle('hidden', bookmarksToRender.length > 0 || currentFolderId === null);
            emptyStateEl.classList.toggle('flex', bookmarksToRender.length === 0 && currentFolderId !== null);
            bookmarkListEl.classList.toggle('hidden', bookmarksToRender.length === 0 && currentFolderId !== null);
            
            if(currentFolderId === null) currentFolderNameEl.textContent = "All Bookmarks";

            bookmarksToRender.forEach(bookmark => {
                const bookmarkEl = document.createElement('div');
                bookmarkEl.dataset.id = bookmark.id;
                bookmarkEl.dataset.type = 'bookmark';
                bookmarkEl.className = 'bg-white p-4 rounded-lg shadow-sm border border-slate-200 hover:shadow-md hover:border-sky-300 transition-all cursor-pointer h-28';

                bookmarkEl.setAttribute('draggable', 'true');
                bookmarkEl.addEventListener('dragstart', e => onDragStart(e, bookmark, 'bookmark'));

                const faviconUrl = new URL('favicon.ico', bookmark.url).href;
                bookmarkEl.innerHTML = `
                    <div class="flex items-center mb-2">
                        <img 
                        src="api/favicon/${bookmark.id}" 
                        onerror="this.onerror=null; this.src='static/weblink.png';" 
                        class="w-5 h-5 mr-3 flex-shrink-0" 
                        alt="favicon"
                        >
                        <h4 class="font-bold truncate">${bookmark.name}</h4>
                    </div>
                    <p class="text-xs text-slate-500 break-all">${bookmark.url}</p>
                `;
                bookmarkListEl.appendChild(bookmarkEl);
                
                bookmarkEl.addEventListener('click', () => window.open(bookmark.url, '_blank'));
                bookmarkEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    contextTarget = { id: bookmark.id, type: 'bookmark' };
                    showContextMenu(e.pageX, e.pageY, false);
                });
            });
        };

        // --- MODAL LOGIC ---
        const openModal = (type, mode, item = null, parentId = null) => {
            modalForm.reset();
            editTypeInput.value = type;
            editIdInput.value = item ? item.id : '';
            itemParentIdInput.value = parentId || '';
            
            urlField.style.display = (type === 'bookmark') ? 'block' : 'none';
            itemUrlInput.required = (type === 'bookmark');

            if (mode === 'add') {
                modalTitleEl.textContent = type === 'bookmark' ? 'Add New Bookmark' : 'Add New Folder';
            } else { // edit
                modalTitleEl.textContent = type === 'bookmark' ? 'Edit Bookmark' : 'Edit Folder';
                itemNameInput.value = item.name;
                if (type === 'bookmark') itemUrlInput.value = item.url;
            }
            modalEl.classList.remove('hidden');
            itemNameInput.focus();
        };

        const closeModal = () => modalEl.classList.add('hidden');

        modalForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const id = editIdInput.value ? parseInt(editIdInput.value) : null;
            const type = editTypeInput.value;
            const name = itemNameInput.value.trim();

            try {
                if (id) { // Edit existing item
                    const payload = { name };
                    if (type === 'bookmark') payload.url = itemUrlInput.value.trim();
                    await api.updateItem(type + 's', id, payload);
                } else { // Create new item
                    if (type === 'bookmark') {
                        await api.createBookmark({ name, url: itemUrlInput.value.trim(), folderId: currentFolderId });
                    } else { // folder
                        const parentId = itemParentIdInput.value ? parseInt(itemParentIdInput.value) : null;
                        await api.createFolder({ name, parentId });
                        await api.updateItem('folders', parentId, { isOpen: true }).catch(() => {});
                    }
                }
                closeModal();
                await loadData();
            } catch (err) {
                console.error('Failed to save item:', err);
                alert('Error: ' + err.message);
            }
        });

        // --- CONTEXT MENU LOGIC ---
        const showContextMenu = (x, y, isFolder) => {
            hideContextMenu();
            contextMenuEl.style.left = `${x}px`;
            contextMenuEl.style.top = `${y}px`;
            contextMenuEl.classList.remove('hidden');
            contextMenuEl.querySelector('[data-action="add-subfolder"]').style.display = isFolder ? 'block' : 'none';
        };

        const hideContextMenu = () => {
            contextMenuEl.classList.add('hidden');
        };

        contextMenuEl.addEventListener('click', async (e) => {
            e.stopPropagation(); // Prevent the global document click from firing
            e.preventDefault();

            const targetButton = e.target.closest('button');
            if (!targetButton) return;

            const action = targetButton.dataset.action;
            const localContext = contextTarget; // Copy so it survives after menu close
            if (!localContext) return;

            const { id, type } = localContext;
            const item = findItem(id, type);

            if (!item) {
                console.error("Context item not found:", localContext);
                return;
            }

            // Perform the action before hiding the menu
            if (action === 'edit') {
                openModal(type, 'edit', item);
            } else if (action === 'delete') {
                if (confirm(`Are you sure you want to delete "${item.name}"? This cannot be undone.`)) {
                    if (type === 'folder') {
                        // Save parent ID before deletion
                        parentId = item.parentId ?? null;
                    }
                    await api.deleteItem(type + 's', id);
                    // Auto-select parent folder if we deleted a folder
                    if (type === 'folder') {
                        currentFolderId = parentId;
                    }
                    await loadData();
                }
            } else if (action === 'add-subfolder') {
                openModal('folder', 'add', null, id);
            }

            // Now hide the menu
            hideContextMenu();
            contextTarget = null;
        });

        // --- DRAG AND DROP LOGIC ---
        let draggedElement = null;

        const separatorEl = document.getElementById('drag-separator');

        function showSeparator(orientation, x, y, length) {
            separatorEl.classList.remove('hidden');
            if (orientation === 'vertical') {
                separatorEl.style.width = '2px';
                separatorEl.style.height = `${length}px`;
                separatorEl.style.transform = `translate(${x}px, ${y}px)`;
            } else {
                separatorEl.style.width = `${length}px`;
                separatorEl.style.height = '2px';
                separatorEl.style.transform = `translate(${x}px, ${y}px)`;
            }
        }

        function hideSeparator() {
            separatorEl.classList.add('hidden');
        }

        function onDragStart(e, item, type) {
            e.stopPropagation();
            draggedElement = { item, type };
            e.dataTransfer.setData('text/plain', ''); // Necessary for Firefox
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => e.target.classList.add('opacity-50'), 0);
        }

        document.addEventListener('dragend', (e) => {
            if (draggedElement) {
                document.querySelectorAll('.opacity-50').forEach(el => el.classList.remove('opacity-50'));
                draggedElement = null;
                hideSeparator();
                clearTimeout(dragTimeout);
                if (dragOverContainer) {
                    dragOverContainer.classList.remove('drag-over');
                    dragOverContainer = null;
                }
            }
        });

        folderTreeEl.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (draggedElement?.type === 'folder') folderTreeEl.classList.add('folder-tree-root-drag-over');
        });
        folderTreeEl.addEventListener('dragleave', () => folderTreeEl.classList.remove('folder-tree-root-drag-over'));
        folderTreeEl.addEventListener('drop', async (e) => {
            folderTreeEl.classList.remove('folder-tree-root-drag-over');
            if (e.target === folderTreeEl && draggedElement?.type === 'folder') {
                await api.updateItem('folders', draggedElement.item.id, { parentId: 0 }); // Use 0 for root
                await loadData();
            }
        });

        function onFolderDragOver(e, targetFolder) {
            e.preventDefault();
            e.stopPropagation();

            if (!draggedElement) return;

            const targetEl = e.currentTarget;
            const rect = targetEl.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const dropZoneHeight = rect.height;

            // Define the threshold for reordering (e.g., 25% from top/bottom)
            const reorderThreshold = dropZoneHeight * 0.25;

            // Logic for moving a folder or bookmark into another folder
            if ((draggedElement.type === 'folder' || draggedElement.type === 'bookmark') && y > reorderThreshold && y < dropZoneHeight - reorderThreshold) {
                if (draggedElement.type === 'folder' && draggedElement.item.id === targetFolder.id) return; // Can't drop folder on itself
                hideSeparator();
                if (dragOverContainer !== targetEl) {
                    dragOverContainer?.classList.remove('drag-over');
                    dragOverContainer = targetEl;
                    dragOverContainer.classList.add('drag-over');
                }
                dragAction = { type: 'move', targetId: targetFolder.id };
            }
            // Logic for reordering a folder
            else if (draggedElement.type === 'folder') {
                dragOverContainer?.classList.remove('drag-over');
                dragOverContainer = null;
                const isAfter = y > dropZoneHeight / 2;
                const parentEl = targetEl.parentElement;

                let children = Array.from(parentEl.children).filter(el => el.matches('[data-type="folder"]'));
                let targetIndex = children.indexOf(targetEl);

                let newPosition = isAfter ? targetIndex + 1 : targetIndex;

                dragAction = {
                    type: 'reorder',
                    targetId: targetFolder.id,
                    parentId: targetFolder.parentId,
                    newPosition
                };

                let x = targetEl.getBoundingClientRect().left;
                let elem_y = isAfter ? targetEl.getBoundingClientRect().bottom : targetEl.getBoundingClientRect().top;

                showSeparator('horizontal', x, elem_y, targetEl.getBoundingClientRect().width);
            }
        }

        function onFolderDragLeave(e) {
            e.stopPropagation();
            // Using a timeout to prevent flickering when moving over child elements
            clearTimeout(dragTimeout);
            dragTimeout = setTimeout(() => {
                hideSeparator();
                dragOverContainer?.classList.remove('drag-over');
                dragOverContainer = null;
                dragAction = null;
            }, 50);
        }

        async function onFolderDrop(e, targetFolder) {
            e.preventDefault();
            e.stopPropagation();
            hideSeparator();
            dragOverContainer?.classList.remove('drag-over');

            if (!draggedElement || !dragAction) return;

            const { item: draggedItem, type: draggedType } = draggedElement;

            try {
                if (dragAction.type === 'move') {
                    if (draggedType === 'folder') {
                        await api.updateItem('folders', draggedItem.id, { parentId: dragAction.targetId });
                    } else { // bookmark
                        await api.updateItem('bookmarks', draggedItem.id, { folderId: dragAction.targetId });
                    }
                } else if (dragAction.type === 'reorder') {
                    const parentId = targetFolder.parentId;
                    const siblings = getSubFolders(parentId);
                    let siblingIds = siblings.map(f => f.id);

                    // Remove dragged item from its original position
                    const originalIndex = siblingIds.indexOf(draggedItem.id);
                    if (originalIndex > -1) {
                        siblingIds.splice(originalIndex, 1);
                    }

                    // Calculate new position
                    let targetIndex = siblingIds.indexOf(targetFolder.id);
                    const isAfter = dragAction.newPosition > siblings.findIndex(s => s.id === targetFolder.id);

                    if (isAfter) targetIndex++;

                    // Insert at new position
                    siblingIds.splice(targetIndex, 0, draggedItem.id);

                    await api.reorderItems('folders', siblingIds);
                }
                await loadData();
            } catch (error) {
                console.error("Drop failed:", error);
                alert("An error occurred. Please try again.");
            } finally {
                draggedElement = null;
                dragAction = null;
            }
        }

        bookmarkListEl.addEventListener('dragover', e => onBookmarkDragOver(e));
        bookmarkListEl.addEventListener('drop', e => onBookmarkDrop(e));

        function onBookmarkDragOver(e) {
            e.preventDefault();

            if (!draggedElement || draggedElement.type !== 'bookmark') return;

            const container = e.currentTarget;
            const containerRect = container.getBoundingClientRect();

            const directChildren = Array.from(container.children);
            const target = directChildren.find(child => {
                const rect = child.getBoundingClientRect();
                return e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
            });

            if (target) {
                const rect = target.getBoundingClientRect();
                const isVertical = container.clientHeight > container.clientWidth;
                let pos, size;

                if (isVertical) {
                    pos = e.clientY - rect.top;
                    size = rect.height;
                } else {
                    pos = e.clientX - rect.left;
                    size = rect.width;
                }

                const isAfter = pos > size / 2;

                const x = isVertical ? rect.left : (isAfter ? rect.right : rect.left);
                const y = isVertical ? (isAfter ? rect.bottom : rect.top) : rect.top;
                const length = isVertical ? rect.width : rect.height;

                showSeparator(isVertical ? 'horizontal' : 'vertical', x, y, length);

                dragAction = {
                    type: 'reorder-bookmark',
                    targetId: parseInt(target.dataset.id),
                    isAfter
                };

            }
        }

        async function onBookmarkDrop(e) {
            e.preventDefault();
            hideSeparator();

            if (!draggedElement || !dragAction || dragAction.type !== 'reorder-bookmark') return;

            const { item: draggedItem } = draggedElement;
            const { targetId, isAfter } = dragAction;

            let siblings = getBookmarksInFolder(currentFolderId);
            let siblingIds = siblings.map(b => b.id);

            siblingIds = siblingIds.filter(id => id !== draggedItem.id);

            const targetIndex = siblingIds.indexOf(targetId);

            if (targetIndex !== -1) {
                siblingIds.splice(targetIndex + (isAfter ? 1 : 0), 0, draggedItem.id);
                await api.reorderItems('bookmarks', siblingIds);
                await loadData();
            }

            draggedElement = null;
            dragAction = null;
        }

        // --- INITIALIZATION ---
        const loadData = async () => {
            try {
                const data = await api.getData();
                allFolders = data.folders;
                allBookmarks = data.bookmarks;

                // Auto-close leaf folders (no subfolders)
                allFolders.forEach(folder => {
                    const hasChildren = allFolders.some(f => f.parentId === folder.id);
                    if (!hasChildren && folder.isOpen) {
                        folder.isOpen = false;
                        // Optionally update backend so it stays closed in DB
                        api.updateItem('folders', folder.id, { isOpen: false }).catch(() => {});
                    }
                });

                render();
            } catch (err) {
                console.error('Failed to load data:', err);
                document.body.innerHTML = `<div class="text-center p-8 text-red-600"><h2>Connection Error</h2><p>Could not connect to the backend server. Is it running?</p><p>${err.message}</p></div>`;
            }
        };

        // --- GLOBAL EVENT LISTENERS ---
        document.getElementById('add-bookmark-btn').addEventListener('click', () => {
            if (currentFolderId !== null) openModal('bookmark', 'add');
            else alert("Please select a folder first to add a bookmark.");
        });
        document.getElementById('add-folder-root-btn').addEventListener('click', () => openModal('folder', 'add', null, null));
        document.getElementById('modal-cancel-btn').addEventListener('click', closeModal);
        modalEl.addEventListener('click', (e) => { if (e.target === modalEl) closeModal(); });
        document.addEventListener('click', (e) => { if (!contextMenuEl.contains(e.target)) hideContextMenu(); });

        loadData();
    });

    if ('serviceWorker' in navigator) {
        navigator.serviceWorker
            .register('sw.js', {updateViaCache: 'none', scope: window.location.pathname})
            .then((reg) => {
                if (reg.active) 
                    reg.active.postMessage('fetched latest service worker script');
                else 
                    console.info('Service worker registered');
            });
    }
    </script>

    <script>
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const sunIcon = themeToggleBtn.querySelector('.fa-sun');
        const moonIcon = themeToggleBtn.querySelector('.fa-moon');

        const applyTheme = (theme) => {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                document.documentElement.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
        };

        themeToggleBtn.addEventListener('click', () => {
            const isDarkMode = document.documentElement.classList.contains('dark');
            const newTheme = isDarkMode ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
        });

        // On page load, apply the saved theme or the user's preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        applyTheme(savedTheme || (prefersDark ? 'dark' : 'light'));
    </script>
</body>
</html>
